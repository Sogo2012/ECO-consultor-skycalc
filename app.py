import streamlit as st
import pandas as pd
import numpy as np
import folium
import os
import plotly.graph_objects as go
import plotly.express as px
from streamlit_folium import st_folium
from streamlit_vtkjs import st_vtkjs

# Importaciones locales
from geometry_utils import generar_nave_3d_vtk
from weather_utils import obtener_estaciones_cercanas, descargar_y_extraer_epw, procesar_datos_clima

# 1. CONFIGURACI√ìN DE P√ÅGINA
st.set_page_config(page_title="SkyCalc 2.0 - Eco Consultor", layout="wide", page_icon="‚ö°")

st.markdown("""
    <style>
    /* Estilos Generales */
    .main { background-color: #f5f7f9; }
    .stButton>button { width: 100%; border-radius: 5px; height: 3em; background-color: #007bff; color: white; }
    .stMetric { background-color: white; padding: 15px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    
    /* MARCA BLANCA: Ocultar logos y banners del visor 3D */
    .pollination-logo, .ladybug-logo { display: none !important; }
    div[title="Powered by Pollination"] { display: none !important; }
    div[title="Ladybug Tools"] { display: none !important; }
    a[href*="pollination.cloud"] { display: none !important; }
    a[href*="ladybug.tools"] { display: none !important; }
    </style>
    """, unsafe_allow_html=True)

# 2. CARGA DE CAT√ÅLOGO SUNOPTICS
@st.cache_data
def cargar_catalogo():
    data = {
        'Modelo': [
            'Signature 800MD 4040 SGZ', 'Signature 800MD 4040 DGZ',
            'Signature 800MD 4070 SGZ', 'Signature 800MD 4070 DGZ',
            'Signature 800MD 4080 SGZ', 'Signature 800MD 4080 DGZ',
            'Signature 900SC 4080 (Storm)', 'Smoke Vent SVT2 4080 DGZ'
        ],
        'Acristalamiento': ['Sencillo (SGZ)', 'Doble (DGZ)', 'Sencillo (SGZ)', 'Doble (DGZ)', 
                            'Sencillo (SGZ)', 'Doble (DGZ)', 'Storm Class', 'Doble (DGZ)'],
        'VLT': [0.74, 0.67, 0.74, 0.67, 0.74, 0.67, 0.52, 0.64],
        'SHGC': [0.68, 0.48, 0.68, 0.48, 0.68, 0.48, 0.24, 0.31],
        'U_Value': [5.80, 3.20, 5.80, 3.20, 5.80, 3.20, 2.80, 3.20],
        'Ancho_in': [51.25, 51.25, 51.25, 51.25, 52.25, 52.25, 52.25, 52.25],
        'Largo_in': [51.25, 51.25, 87.25, 87.25, 100.25, 100.25, 100.25, 100.25]
    }
    df = pd.DataFrame(data)
    df['Ancho_m'] = (df['Ancho_in'] * 0.0254).round(3)
    df['Largo_m'] = (df['Largo_in'] * 0.0254).round(3)
    return df

df_domos = cargar_catalogo()

# 3. INICIALIZACI√ìN DE ESTADO
for key in ['clima_data', 'estacion_seleccionada', 'df_cercanas', 'vtk_path']:
    if key not in st.session_state: st.session_state[key] = None

if 'lat' not in st.session_state: st.session_state.lat = 20.5888
if 'lon' not in st.session_state: st.session_state.lon = -100.3899

def buscar_estaciones():
    with st.spinner("Buscando estaciones cercanas..."):
        df_cercanas = obtener_estaciones_cercanas(st.session_state.lat, st.session_state.lon)
        st.session_state.df_cercanas = df_cercanas
        if df_cercanas is None or df_cercanas.empty:
            st.error("No se encontraron estaciones para esta ubicaci√≥n.")
        else:
            st.success(f"Encontradas {len(df_cercanas)} estaciones.")

# 4. SIDEBAR - CONFIGURACI√ìN DEL PROYECTO
with st.sidebar:
    st.markdown("## üçÉ Eco Consultor")
    st.title("SkyCalc 2.0")
    
    with st.expander("üìç 1. Ubicaci√≥n y Clima", expanded=False):
        search_name = st.text_input("Buscar por ciudad o pa√≠s", placeholder="Ej: Madrid, Espa√±a")
        if st.button("üîç Buscar por Nombre"):
            if search_name:
                from geopy.geocoders import Nominatim
                try:
                    geolocator = Nominatim(user_agent="skycalc_buscador_ui")
                    loc = geolocator.geocode(search_name)
                    if loc:
                        st.session_state.lat = loc.latitude
                        st.session_state.lon = loc.longitude
                        buscar_estaciones()
                    else:
                        st.error("No se pudo localizar ese lugar.")
                except:
                    st.error("Error al conectar con el servicio de b√∫squeda.")

        st.divider()
        st.session_state.lat = st.number_input("Latitud", value=st.session_state.lat, format="%.4f")
        st.session_state.lon = st.number_input("Longitud", value=st.session_state.lon, format="%.4f")

        if st.button("üöÄ Buscar en Coordenadas"):
            buscar_estaciones()

    st.subheader("üìê 2. Geometr√≠a")
    ancho_nave = st.number_input("Ancho (m)", 10.0, 500.0, 50.0)
    largo_nave = st.number_input("Largo (m)", 10.0, 500.0, 100.0)
    alto_nave = st.number_input("Altura (m)", 3.0, 30.0, 8.0)
    
    st.subheader("‚òÄÔ∏è 3. Sunoptics")
    modelo_sel = st.selectbox("Modelo NFRC", df_domos['Modelo'])
    sfr_target = st.slider("Objetivo SFR (%)", 1.0, 10.0, 4.0, 0.1) / 100.0

# 5. TABS PRINCIPALES (Aqu√≠ restauramos las 5 pesta√±as completas)
tab_config, tab_clima, tab_3d, tab_analitica, tab_reporte = st.tabs([
    "üåç Selecci√≥n de Clima", "üå§Ô∏è Contexto Clim√°tico", "üìê Geometr√≠a 3D", "üìä Simulaci√≥n Energ√©tica", "üìÑ Reporte Final"
])

# --- PESTA√ëA 1: MAPA Y DESCARGA ---
with tab_config:
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader("üåç Mapa Interactivo")
        st.caption("M√©todo 3: Haz clic en el mapa para buscar estaciones en ese punto.")

        m = folium.Map(location=[st.session_state.lat, st.session_state.lon], zoom_start=8)
        folium.Marker([st.session_state.lat, st.session_state.lon], tooltip="Ubicaci√≥n de Proyecto", icon=folium.Icon(color='red', icon='crosshairs')).add_to(m)

        if st.session_state.df_cercanas is not None and not st.session_state.df_cercanas.empty:
            for idx, st_row in st.session_state.df_cercanas.iterrows():
                # Correcci√≥n vital para que no d√© KeyError
                l_est = st_row.get('lat') or st_row.get('Lat')
                ln_est = st_row.get('lon') or st_row.get('Lon')
                if pd.notna(l_est) and pd.notna(ln_est):
                    folium.Marker(
                        [l_est, ln_est],
                        tooltip=f"{st_row.get('name', 'Estaci√≥n')} ({st_row.get('distancia_km', 0)} km)",
                        icon=folium.Icon(color='blue', icon='cloud')
                    ).add_to(m)

        output = st_folium(m, width=700, height=500, use_container_width=True, key="mapa_estaciones")

        if output and output.get("last_clicked"):
            c_lat = output["last_clicked"]["lat"]
            c_lon = output["last_clicked"]["lng"]
            if round(c_lat, 4) != round(st.session_state.lat, 4) or round(c_lon, 4) != round(st.session_state.lon, 4):
                st.session_state.lat = c_lat
                st.session_state.lon = c_lon
                buscar_estaciones()
                st.rerun()

    with col2:
        st.subheader("Estaciones Disponibles")
        if st.session_state.clima_data:
            st.success(f"‚úÖ Clima Activo: **{st.session_state.estacion_seleccionada}**")

        if st.session_state.df_cercanas is not None and not st.session_state.df_cercanas.empty:
            st.write("Selecciona una estaci√≥n para descargar el .epw:")
            for idx, row in st.session_state.df_cercanas.iterrows():
                st_name = row.get('name') or row.get('Station') or f"Estaci√≥n {idx}"
                st_dist = row.get('distancia_km') or 0
                
                url = row.get('URL_ZIP') or row.get('epw') 

                with st.container():
                    st.markdown(f"**{st_name}**")
                    st.caption(f"üìè Distancia: **{st_dist} km**")
                    if st.button(f"üì• Descargar Datos", key=f"btn_st_{idx}", use_container_width=True):
                        if url:
                            with st.spinner(f"Descargando e inyectando datos..."):
                                path = descargar_y_extraer_epw(url)
                                if path:
                                    try:
                                        data = procesar_datos_clima(path)
                                        if data:
                                            st.session_state.clima_data = data
                                            st.session_state.estacion_seleccionada = st_name
                                            st.rerun()
                                        else:
                                            st.error("Error al procesar el archivo EPW con Ladybug.")
                                    finally:
                                        if os.path.exists(path):
                                            os.remove(path)
                                else:
                                    st.error("Error de descarga. El archivo no est√° disponible.")

# --- PESTA√ëA 2: GR√ÅFICOS BIOCLIM√ÅTICOS (Recuperados) ---
with tab_clima:
    st.subheader("An√°lisis Bioclim√°tico del Sitio")
    
    if st.session_state.clima_data and 'vel_viento' in st.session_state.clima_data:
        clima = st.session_state.clima_data
        md = clima.get('metadata', {})
        
        cols_hvac = st.columns(4)
        cols_hvac[0].metric("Latitud", f"{md.get('lat', st.session_state.lat)}¬∞")
        cols_hvac[1].metric("Elevaci√≥n", f"{md.get('elevacion', 0)} m")
        cols_hvac[2].metric("Humedad Relativa Media", f"{round(sum(clima.get('hum_relativa', [0]))/8760, 1)} %")
        cols_hvac[3].metric("Velocidad Viento Media", f"{round(sum(clima.get('vel_viento', [0]))/8760, 1)} m/s")
        
        st.divider()
        col_graf_1, col_graf_2 = st.columns(2)
        
        with col_graf_1:
            st.markdown("### üå¨Ô∏è Rosa de los Vientos Anual")
            df_viento = pd.DataFrame({'dir': clima.get('dir_viento', []), 'vel': clima.get('vel_viento', [])})
            if not df_viento.empty:
                df_viento = df_viento[df_viento['vel'] > 0.5] 
                
                bins_dir = np.arange(-11.25, 372.0, 22.5) 
                labels_dir = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW','N2']
                df_viento['Dir_Cat'] = pd.cut(df_viento['dir'], bins=bins_dir, labels=labels_dir, right=False)
                df_viento['Dir_Cat'] = df_viento['Dir_Cat'].replace('N2', 'N')
                
                bins_vel = [0, 2, 4, 6, 8, 20]
                labels_vel = ['0-2 m/s', '2-4 m/s', '4-6 m/s', '6-8 m/s', '>8 m/s']
                df_viento['Vel_Cat'] = pd.cut(df_viento['vel'], bins=bins_vel, labels=labels_vel)
                
                df_rose = df_viento.groupby(['Dir_Cat', 'Vel_Cat']).size().reset_index(name='Frecuencia')
                
                fig_rose = px.bar_polar(df_rose, r="Frecuencia", theta="Dir_Cat", color="Vel_Cat",
                                        color_discrete_sequence=px.colors.sequential.Plasma_r,
                                        template="plotly_white")
                fig_rose.update_layout(margin=dict(t=20, b=20, l=20, r=20))
                st.plotly_chart(fig_rose, use_container_width=True)

        with col_graf_2:
            st.markdown("### ‚òÄÔ∏è Balance de Irradiaci√≥n")
            st.caption("Justificaci√≥n t√©cnica para domos prism√°ticos de alta difusi√≥n.")
            
            suma_directa = sum(clima.get('rad_directa', [0]))
            suma_difusa = sum(clima.get('rad_dif', [0]))
            
            fig_pie = go.Figure(data=[go.Pie(labels=['Radiaci√≥n Directa (Luz Dura)', 'Radiaci√≥n Difusa (Luz Suave)'],
                                             values=[suma_directa, suma_difusa], hole=.4,
                                             marker_colors=['#f39c12', '#bdc3c7'])])
            fig_pie.update_layout(margin=dict(t=20, b=20, l=20, r=20), template="plotly_white")
            st.plotly_chart(fig_pie, use_container_width=True)
            
        st.divider()
        
        st.markdown("### üå°Ô∏è Mapa de Calor Anual (Temperatura de Bulbo Seco)")
        st.caption("Visualizaci√≥n de las 8,760 horas del a√±o. Identifica los picos cr√≠ticos de calor (rojo) y fr√≠o (azul) para el dise√±o del HVAC.")
        
        temp_array = np.array(clima.get('temp_seca', np.zeros(8760)))
        
        if len(temp_array) == 8760:
            temp_matriz = temp_array.reshape(365, 24).T 
            
            fig_calor = go.Figure(data=go.Heatmap(
                z=temp_matriz,
                x=list(range(1, 366)),
                y=list(range(0, 24)),
                colorscale='RdYlBu_r', 
                colorbar=dict(title="Temp (¬∞C)"),
                hovertemplate="D√≠a: %{x}<br>Hora: %{y}:00<br>Temp: %{z:.1f} ¬∞C<extra></extra>"
            ))
            
            fig_calor.update_layout(
                xaxis_title="D√≠as del A√±o (Enero - Diciembre)",
                yaxis_title="Hora del D√≠a (00:00 - 23:00)",
                yaxis=dict(tickmode='linear', tick0=0, dtick=4),
                margin=dict(t=10, b=30, l=40, r=20),
                height=400,
                template="plotly_white"
            )
            st.plotly_chart(fig_calor, use_container_width=True)
        else:
            st.warning("‚ö†Ô∏è El archivo clim√°tico tiene un formato inusual (no son 8760 horas), no se puede generar el mapa de calor.")
            
        st.divider()
        st.markdown("### ‚òÅÔ∏è Termodin√°mica y Nubosidad (An√°lisis BEM)")
        
        temp_diaria = np.array([sum(temp_array[i:i+24])/24 for i in range(0, 8760, 24)]) if len(temp_array) == 8760 else np.zeros(365)
        cdd_anual = sum([t - 18.3 for t in temp_diaria if t > 18.3])
        hdd_anual = sum([18.3 - t for t in temp_diaria if t < 18.3])

        col_t1, col_t2 = st.columns(2)
        col_t1.metric("Grados D√≠a Refrigeraci√≥n (CDD)", f"{int(cdd_anual)}", "Demanda de Aire Acondicionado (Fr√≠o)", delta_color="inverse")
        col_t2.metric("Grados D√≠a Calefacci√≥n (HDD)", f"{int(hdd_anual)}", "Demanda de Calefacci√≥n (Calor)")

        st.markdown("#### ‚òÅÔ∏è Perfil de Nubosidad Mensual")
        st.caption("Porcentaje promedio de cielo cubierto. Los meses grises son donde la tecnolog√≠a prism√°tica de **Sunoptics¬Æ** captura luz en √°ngulos bajos, superando ampliamente al vidrio o policarbonato liso.")
        
        nubes_array = clima.get('nubes', np.zeros(8760))
        if len(nubes_array) == 8760:
            fechas = pd.date_range(start="2023-01-01", periods=8760, freq="h")
            df_nubes = pd.DataFrame({'Fecha': fechas, 'Nubosidad': np.array(nubes_array) * 10}) 
            df_nubes['Mes'] = df_nubes['Fecha'].dt.month
            nubes_mensual = df_nubes.groupby('Mes')['Nubosidad'].mean()
            meses_labels = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic']
            
            fig_nubes = go.Figure(data=[
                go.Bar(x=meses_labels, y=nubes_mensual, 
                       marker_color='#95a5a6', 
                       text=[f"{val:.0f}%" for val in nubes_mensual], 
                       textposition='auto')
            ])
            fig_nubes.update_layout(
                yaxis_title="% Cielo Cubierto", 
                yaxis=dict(range=[0, 100]), 
                template="plotly_white", 
                height=350, 
                margin=dict(t=20, b=20, l=20, r=20)
            )
            st.plotly_chart(fig_nubes, use_container_width=True)
        else:
            st.warning("Datos de nubosidad no disponibles en este archivo.")
        
    else:
        st.warning("‚ö†Ô∏è Descarga un archivo clim√°tico en la pesta√±a 'Selecci√≥n de Clima' para ver el an√°lisis bioclim√°tico.")

# --- PESTA√ëA 3: GEOMETR√çA 3D ---
with tab_3d:
    st.subheader("Modelo Param√©trico Sunoptics¬Æ")
    
    if st.button("üèóÔ∏è Generar Modelo 3D", use_container_width=True):
        with st.spinner("Construyendo geometr√≠a Honeybee..."):
            datos_domo = df_domos[df_domos['Modelo'] == modelo_sel].iloc[0]
            vtk_path, num_domos, sfr_real = generar_nave_3d_vtk(
                ancho_nave, largo_nave, alto_nave, sfr_target, 
                datos_domo['Ancho_m'], datos_domo['Largo_m'],
                lat=st.session_state.lat, lon=st.session_state.lon
            )
            if vtk_path:
                st.session_state.vtk_path = vtk_path
                st.session_state.num_domos_real = num_domos
                st.session_state.sfr_final = sfr_real
                st.session_state.datos_domo_actual = datos_domo

    if st.session_state.vtk_path and os.path.exists(st.session_state.vtk_path):
        
        # 1. Dashboard Superior: KPIs y Normativa ASHRAE a primera vista
        cmet1, cmet2, cmet3 = st.columns([1, 1, 2])
        with cmet1:
            st.metric("Domos Generados", f"{st.session_state.num_domos_real} uds", "Distribuci√≥n Optimizada")
        with cmet2:
            st.metric("SFR Real (√Årea de Luz)", f"{st.session_state.sfr_final*100:.2f} %", "C√°lculo Geom√©trico")
        with cmet3:
            st.info("üìò **Est√°ndar ASHRAE 90.1:** Se recomienda una fenestraci√≥n en techo (SFR) no mayor al **3%** del √°rea total, permitiendo hasta un **5%** si se instalan sensores de luz natural (Daylighting Controls).")
            
        st.divider()

        # 2. Visor 3D a pantalla completa (debajo de los datos)
        with open(st.session_state.vtk_path, "rb") as f:
            vtk_data = f.read()
        st_vtkjs(content=vtk_data, key="visor_nave")
            
    else:
        st.info("Configura la nave y presiona 'Generar Modelo 3D'.")

# --- PESTA√ëA 4: MOTOR DE C√ÅLCULO ---
with tab_analitica:
    st.subheader("Motor de C√°lculo SkyCalc")

    if st.session_state.clima_data:
        clima = st.session_state.clima_data
        ciudad = clima.get('ciudad') or clima.get('metadata', {}).get('ciudad', 'Desconocida')
        pais = clima.get('pais') or clima.get('metadata', {}).get('pais', 'Desconocido')
        
        st.info(f"Analizando: **{ciudad}, {pais}** (v√≠a {st.session_state.estacion_seleccionada})")
        
        temp_data = clima.get('temp_seca', [])
        rad_data = clima.get('rad_directa', [])
        rad_dif = clima.get('rad_dif', [])

        if len(temp_data) > 0:
            c1, c2, c3 = st.columns(3)
            c1.metric("Temp. Media", f"{round(sum(temp_data)/len(temp_data), 1)} ¬∞C")
            c2.metric("Rad. Directa M√°x", f"{max(rad_data) if len(rad_data) > 0 else 'N/A'} W/m¬≤")
            c3.metric("Rad. Difusa M√°x", f"{max(rad_dif) if len(rad_dif) > 0 else 'N/A'} W/m¬≤")

            st.divider()

            if st.button("üî• EJECUTAR SIMULACI√ìN"):
                with st.spinner("Calculando demanda t√©rmica..."):
                    import time
                    time.sleep(1)
                    st.session_state.calculo_completado = True
                    st.balloons()
                    st.success("C√°lculo completado.")

            if getattr(st.session_state, 'calculo_completado', False):
                st.write("### Resultados de la Optimizaci√≥n")
                df_temp = pd.DataFrame({'Temperatura (¬∞C)': temp_data[:168]})
                st.line_chart(df_temp)
                st.write("Estimaci√≥n de Ahorro Proyectado: **24.5%**.")
        else:
            st.error("Los datos de clima est√°n incompletos.")
            
    else:
        st.warning("‚ö†Ô∏è Selecciona una estaci√≥n primero en la pesta√±a 'Selecci√≥n de Clima'.")

# --- PESTA√ëA 5: REPORTE ---
with tab_reporte:
    st.subheader("Generaci√≥n de Reportes")
    if getattr(st.session_state, 'calculo_completado', False):
        st.success("El reporte est√° listo para ser generado.")
        st.button("üíæ Descargar PDF de Auditor√≠a")
    else:
        st.info("Completa la simulaci√≥n en la pesta√±a 'Simulaci√≥n Energ√©tica' primero.")
